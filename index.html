<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TWSL Team Formation Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
        }

        .main-content {
            padding: 40px;
        }

        .upload-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px dashed #dee2e6;
            text-align: center;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            border-color: #3498db;
            background: #f0f7ff;
        }

        .file-input {
            display: none;
        }

        .file-label {
            display: inline-block;
            background: #3498db;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.1rem;
            transition: background 0.3s ease;
            margin-bottom: 15px;
        }

        .file-label:hover {
            background: #2980b9;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .control-group select,
        .control-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 6px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .control-group select:focus,
        .control-group input:focus {
            outline: none;
            border-color: #3498db;
        }

        .generate-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.2rem;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 30px;
        }

        .generate-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(39, 174, 96, 0.3);
        }

        .generate-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .results {
            display: none;
        }

        .results.show {
            display: block;
        }

        .stats {
            background: #e8f5e8;
            border: 1px solid #27ae60;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
        }

        .stats h3 {
            color: #27ae60;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .stat-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .stat-label {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .teams-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .team-card {
            background: white;
            border: 1px solid #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .team-header {
            background: #3498db;
            color: white;
            padding: 15px;
            font-weight: bold;
            text-align: center;
        }

        .team-content {
            padding: 15px;
        }

        .player-list {
            list-style: none;
        }

        .player-item {
            padding: 8px 0;
            border-bottom: 1px solid #f8f9fa;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-item:last-child {
            border-bottom: none;
        }

        .player-name {
            font-weight: 500;
        }

        .player-details {
            font-size: 0.85rem;
            color: #6c757d;
        }

        .download-btn {
            background: #9b59b6;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            margin-right: 10px;
            transition: background 0.3s ease;
        }

        .download-btn:hover {
            background: #8e44ad;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #f5c6cb;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #6c757d;
        }

        @media (max-width: 768px) {
            .header h1 {
                font-size: 2rem;
            }
            
            .main-content {
                padding: 20px;
            }
            
            .controls {
                grid-template-columns: 1fr;
            }
            
            .teams-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>TWSL Team Formation Tool</h1>
            <p>Automated team balancing for the Tidewater Women's Soccer League</p>
        </div>
        
        <div class="main-content">
            <div class="upload-section">
                <input type="file" id="csvFile" class="file-input" accept=".csv" />
                <label for="csvFile" class="file-label">üìÑ Upload Player CSV</label>
                <p id="fileInfo" style="margin-top: 10px; color: #6c757d;"></p>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label for="division">Division:</label>
                    <select id="division">
                        <option value="">Select Division</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="teamCount">Number of Teams:</label>
                    <input type="number" id="teamCount" min="2" max="20" value="8" />
                </div>
            </div>

            <button id="generateTeams" class="generate-btn" disabled>Generate Teams</button>

            <div id="error" class="error" style="display: none;"></div>
            <div id="loading" class="loading" style="display: none;">
                <p>üèóÔ∏è Generating balanced teams...</p>
            </div>

            <div id="results" class="results">
                <div id="stats" class="stats"></div>
                <div class="download-section" style="margin-bottom: 30px;">
                    <button id="downloadTeams" class="download-btn">üì• Download Teams CSV</button>
                    <button id="downloadStats" class="download-btn">üìä Download Statistics CSV</button>
                </div>
                <div id="teamsDisplay" class="teams-grid"></div>
            </div>
        </div>
    </div>

    <script>
        let playerData = [];
        let availableDivisions = [];
        let generatedTeams = [];
        let teamStats = {};

        // File upload handling
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('fileInfo').textContent = `Selected: ${file.name}`;
                parseCSV(file);
            }
        });

        function parseCSV(file) {
            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: true,
                complete: function(results) {
                    try {
                        processPlayerData(results.data);
                        populateDivisions();
                        document.getElementById('generateTeams').disabled = false;
                        hideError();
                    } catch (error) {
                        showError('Error processing CSV: ' + error.message);
                    }
                },
                error: function(error) {
                    showError('Error parsing CSV: ' + error.message);
                }
            });
        }

        function processPlayerData(data) {
            playerData = data.filter(row => {
                // Skip rows without names or tally rows
                return row['Full Name'] && 
                       typeof row['Full Name'] === 'string' && 
                       row['Full Name'].trim() !== '' &&
                       !row['Full Name'].toLowerCase().includes('tally');
            });

            // Extract available divisions
            availableDivisions = [];
            const divisionColumns = ['Open Division', 'Over 30 Division', 'Over 40 Division'];
            
            divisionColumns.forEach(col => {
                if (playerData.some(player => player[col] === 'Yes' || player[col] === 'yes' || player[col] === true)) {
                    availableDivisions.push(col);
                }
            });

            if (availableDivisions.length === 0) {
                throw new Error('No divisions found in the data');
            }
        }

        function populateDivisions() {
            const divisionSelect = document.getElementById('division');
            divisionSelect.innerHTML = '<option value="">Select Division</option>';
            
            availableDivisions.forEach(division => {
                const option = document.createElement('option');
                option.value = division;
                option.textContent = division.replace(' Division', '');
                divisionSelect.appendChild(option);
            });
        }

        // Team generation
        document.getElementById('generateTeams').addEventListener('click', generateTeams);

        function generateTeams() {
            const division = document.getElementById('division').value;
            const teamCount = parseInt(document.getElementById('teamCount').value);

            if (!division || !teamCount) {
                showError('Please select a division and number of teams');
                return;
            }

            document.getElementById('loading').style.display = 'block';
            document.getElementById('results').classList.remove('show');

            // Small delay to show loading
            setTimeout(() => {
                try {
                    const divisionPlayers = getDivisionPlayers(division);
                    if (divisionPlayers.length === 0) {
                        throw new Error('No players found for selected division');
                    }

                    const teams = balanceTeams(divisionPlayers, teamCount);
                    generatedTeams = teams;
                    teamStats = calculateStats(teams, divisionPlayers);
                    
                    displayResults(teams);
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('results').classList.add('show');
                } catch (error) {
                    document.getElementById('loading').style.display = 'none';
                    showError('Error generating teams: ' + error.message);
                }
            }, 500);
        }

        function getDivisionPlayers(division) {
            return playerData.filter(player => 
                player[division] === 'Yes' || 
                player[division] === 'yes' || 
                player[division] === true
            ).map(player => ({
                name: player['Full Name'],
                experience: parseFloat(player['Board Assigned Experience (1-3)']) || 1,
                position: player['Position'] || 'Field Player',
                missedGames: player['Missed Games'] || '0',
                isTR: player['TR'] === 'Yes' || player['TR'] === 'yes' || player['TR'] === true,
                openRequests: parseRequests(player['(Open Division) Requests']),
                o30Requests: parseRequests(player['(O30 or O40) Requests']),
                allRequests: [
                    ...parseRequests(player['(Open Division) Requests']),
                    ...parseRequests(player['(O30 or O40) Requests'])
                ]
            }));
        }

        function parseRequests(requestString) {
            if (!requestString || typeof requestString !== 'string') return [];
            return requestString.split(',')
                .map(name => name.trim())
                .filter(name => name.length > 0);
        }

        function balanceTeams(players, teamCount) {
            // Initialize teams
            const teams = Array.from({ length: teamCount }, (_, i) => ({
                id: i + 1,
                name: `Team ${i + 1}`,
                players: [],
                totalExperience: 0,
                goalkeepers: 0,
                teamReps: 0,
                positions: {},
                missedGamesDistribution: {}
            }));

            // Create a copy of players to work with
            let availablePlayers = [...players];

            // Step 1: Handle reciprocal requests first (highest priority)
            const reciprocalPairs = findReciprocalRequests(availablePlayers);
            reciprocalPairs.forEach(pair => {
                const bestTeam = findBestTeamForPair(teams, pair);
                addPlayerToTeam(teams[bestTeam], pair[0]);
                addPlayerToTeam(teams[bestTeam], pair[1]);
                availablePlayers = availablePlayers.filter(p => 
                    p.name !== pair[0].name && p.name !== pair[1].name
                );
            });

            // Step 2: Distribute goalkeepers
            const goalkeepers = availablePlayers.filter(p => 
                p.position.toLowerCase().includes('goal') || 
                p.position.toLowerCase().includes('keeper')
            );
            
            goalkeepers.forEach(gk => {
                const bestTeam = findBestTeamForGoalkeeper(teams, gk);
                addPlayerToTeam(teams[bestTeam], gk);
                availablePlayers = availablePlayers.filter(p => p.name !== gk.name);
            });

            // Step 3: Distribute Team Representatives
            const teamReps = availablePlayers.filter(p => p.isTR);
            teamReps.forEach(tr => {
                const bestTeam = findBestTeamForTR(teams, tr);
                addPlayerToTeam(teams[bestTeam], tr);
                availablePlayers = availablePlayers.filter(p => p.name !== tr.name);
            });

            // Step 4: Handle one-way requests
            const playersWithRequests = availablePlayers.filter(p => p.allRequests.length > 0);
            playersWithRequests.forEach(player => {
                const bestTeam = findBestTeamForRequestedPlayer(teams, player, availablePlayers);
                if (bestTeam !== -1) {
                    addPlayerToTeam(teams[bestTeam], player);
                    availablePlayers = availablePlayers.filter(p => p.name !== player.name);
                }
            });

            // Step 5: Distribute remaining players by experience and missed games
            availablePlayers.sort((a, b) => {
                // Sort by experience (high to low), then by missed games (high to low)
                if (a.experience !== b.experience) {
                    return b.experience - a.experience;
                }
                return getMissedGamesWeight(b.missedGames) - getMissedGamesWeight(a.missedGames);
            });

            availablePlayers.forEach(player => {
                const bestTeam = findBestBalancedTeam(teams, player);
                addPlayerToTeam(teams[bestTeam], player);
            });

            return teams;
        }

        function findReciprocalRequests(players) {
            const pairs = [];
            const processed = new Set();

            players.forEach(player => {
                if (processed.has(player.name)) return;

                player.allRequests.forEach(requestedName => {
                    const requestedPlayer = players.find(p => 
                        matchesName(p.name, requestedName) && !processed.has(p.name)
                    );
                    
                    if (requestedPlayer && 
                        requestedPlayer.allRequests.some(name => matchesName(name, player.name))) {
                        pairs.push([player, requestedPlayer]);
                        processed.add(player.name);
                        processed.add(requestedPlayer.name);
                    }
                });
            });

            return pairs;
        }

        function matchesName(fullName, requestName) {
            const full = fullName.toLowerCase().trim();
            const request = requestName.toLowerCase().trim();
            
            // Exact match
            if (full === request) return true;
            
            // First name match
            const firstName = full.split(' ')[0];
            if (firstName === request) return true;
            
            // Contains match
            if (full.includes(request) || request.includes(firstName)) return true;
            
            return false;
        }

        function findBestTeamForPair(teams, pair) {
            let bestTeam = 0;
            let bestScore = Infinity;

            teams.forEach((team, index) => {
                const experienceAfter = team.totalExperience + pair[0].experience + pair[1].experience;
                const sizeAfter = team.players.length + 2;
                const score = experienceAfter / sizeAfter;
                
                if (score < bestScore) {
                    bestScore = score;
                    bestTeam = index;
                }
            });

            return bestTeam;
        }

        function findBestTeamForGoalkeeper(teams, gk) {
            // Prefer teams without goalkeepers, honor any requests
            const teamsWithoutGK = teams.filter(team => team.goalkeepers === 0);
            if (teamsWithoutGK.length > 0) {
                return findBestTeamForRequestedPlayer(teamsWithoutGK.map(team => teams.indexOf(team)), gk, []);
            }
            return findBestBalancedTeam(teams, gk);
        }

        function findBestTeamForTR(teams, tr) {
            const teamsWithoutTR = teams.filter(team => team.teamReps === 0);
            if (teamsWithoutTR.length > 0) {
                const indices = teamsWithoutTR.map(team => teams.indexOf(team));
                return findBestBalancedTeam(indices.map(i => teams[i]), tr, indices);
            }
            return findBestBalancedTeam(teams, tr);
        }

                    function findBestTeamForRequestedPlayer(teams, player, availablePlayers) {
                // If this is called with team indices array, handle it properly
                const teamsToCheck = Array.isArray(teams) && typeof teams[0] === 'number' ? 
                    teams.map(i => ({ ...generatedTeams[i], index: i })) : 
                    teams.map((team, i) => ({ ...team, index: i }));

                let bestTeam = -1;
                let bestScore = -1;

                teamsToCheck.forEach((team) => {
                    let score = 0;
                    
                    // Check if any requested players are on this team
                    player.allRequests.forEach(requestName => {
                        const isOnTeam = team.players.some(p => matchesName(p.name, requestName));
                        if (isOnTeam) score += 10;
                    });

                    if (score > bestScore) {
                        bestScore = score;
                        bestTeam = team.index;
                    }
                });

                return bestTeam === -1 ? findBestBalancedTeam(teams, player) : bestTeam;
            }

        function findBestBalancedTeam(teams, player, teamIndices = null) {
            const teamsToCheck = teamIndices || teams.map((_, i) => i);
            let bestTeam = teamsToCheck[0];
            let bestScore = Infinity;

            teamsToCheck.forEach(index => {
                const team = teams[index];
                const experienceAfter = team.totalExperience + player.experience;
                const sizeAfter = team.players.length + 1;
                const avgExperienceAfter = experienceAfter / sizeAfter;
                
                // Factor in team size (prefer smaller teams)
                const sizeWeight = team.players.length * 0.1;
                const score = avgExperienceAfter + sizeWeight;
                
                if (score < bestScore) {
                    bestScore = score;
                    bestTeam = index;
                }
            });

            return bestTeam;
        }

        function addPlayerToTeam(team, player) {
            team.players.push(player);
            team.totalExperience += player.experience;
            
            if (player.position.toLowerCase().includes('goal')) {
                team.goalkeepers++;
            }
            
            if (player.isTR) {
                team.teamReps++;
            }
            
            // Track positions
            const pos = player.position || 'Field Player';
            team.positions[pos] = (team.positions[pos] || 0) + 1;
            
            // Track missed games
            team.missedGamesDistribution[player.missedGames] = 
                (team.missedGamesDistribution[player.missedGames] || 0) + 1;
        }

        function getMissedGamesWeight(missedGames) {
            if (typeof missedGames !== 'string') return 0;
            const lower = missedGames.toLowerCase();
            if (lower.includes('4+') || lower.includes('4 or more')) return 4;
            if (lower.includes('3-4') || lower.includes('3 to 4')) return 3.5;
            if (lower.includes('1-2') || lower.includes('1 to 2')) return 1.5;
            return 0;
        }

        function calculateStats(teams, allPlayers) {
            const totalPlayers = allPlayers.length;
            const avgExperience = allPlayers.reduce((sum, p) => sum + p.experience, 0) / totalPlayers;
            
            const teamExperiences = teams.map(team => 
                team.players.length > 0 ? team.totalExperience / team.players.length : 0
            );
            
            const experienceVariance = teamExperiences.reduce((sum, exp) => 
                sum + Math.pow(exp - avgExperience, 2), 0
            ) / teams.length;
            
            const teamsWithGoalkeepers = teams.filter(team => team.goalkeepers > 0).length;
            const teamsWithTRs = teams.filter(team => team.teamReps > 0).length;
            
            const reciprocalPairs = findReciprocalRequests(allPlayers).length;
            const totalRequests = allPlayers.reduce((sum, p) => sum + p.allRequests.length, 0);

            return {
                totalPlayers,
                avgExperience: avgExperience.toFixed(2),
                experienceVariance: experienceVariance.toFixed(3),
                teamsWithGoalkeepers,
                teamsWithTRs,
                reciprocalPairs,
                totalRequests,
                teamSizes: teams.map(team => team.players.length)
            };
        }

        function displayResults(teams) {
            displayStats();
            displayTeams(teams);
        }

        function displayStats() {
            const statsDiv = document.getElementById('stats');
            statsDiv.innerHTML = `
                <h3>üìä Team Formation Statistics</h3>
                <div class="stat-grid">
                    <div class="stat-item">
                        <div class="stat-value">${teamStats.totalPlayers}</div>
                        <div class="stat-label">Total Players</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${teamStats.avgExperience}</div>
                        <div class="stat-label">Avg Experience</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${teamStats.experienceVariance}</div>
                        <div class="stat-label">Experience Variance</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${teamStats.teamsWithGoalkeepers}</div>
                        <div class="stat-label">Teams with Goalkeepers</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${teamStats.teamsWithTRs}</div>
                        <div class="stat-label">Teams with TRs</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value">${teamStats.reciprocalPairs}</div>
                        <div class="stat-label">Reciprocal Pairs Honored</div>
                    </div>
                </div>
            `;
        }

        function displayTeams(teams) {
            const teamsDiv = document.getElementById('teamsDisplay');
            teamsDiv.innerHTML = teams.map(team => {
                const avgExp = team.players.length > 0 ? 
                    (team.totalExperience / team.players.length).toFixed(2) : '0.00';
                
                return `
                    <div class="team-card">
                        <div class="team-header">
                            ${team.name} (${team.players.length} players)
                            <br><small>Avg Experience: ${avgExp}</small>
                        </div>
                        <div class="team-content">
                            <ul class="player-list">
                                ${team.players.map(player => `
                                    <li class="player-item">
                                        <span class="player-name">${player.name}</span>
                                        <span class="player-details">
                                            ${player.experience} | ${player.position}
                                            ${player.isTR ? ' | TR' : ''}
                                            ${player.position.toLowerCase().includes('goal') ? ' | GK' : ''}
                                        </span>
                                    </li>
                                `).join('')}
                            </ul>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Download functionality
        document.getElementById('downloadTeams').addEventListener('click', downloadTeamsCSV);
        document.getElementById('downloadStats').addEventListener('click', downloadStatsCSV);

        function downloadTeamsCSV() {
            const csvData = [];
            csvData.push(['Team', 'Player Name', 'Experience', 'Position', 'Missed Games', 'Team Rep']);
            
            generatedTeams.forEach(team => {
                team.players.forEach(player => {
                    csvData.push([
                        team.name,
                        player.name,
                        player.experience,
                        player.position,
                        player.missedGames,
                        player.isTR ? 'Yes' : 'No'
                    ]);
                });
            });

            downloadCSV(csvData, 'teams.csv');
        }

        function downloadStatsCSV() {
            const csvData = [];
            csvData.push(['Metric', 'Value']);
            csvData.push(['Total Players', teamStats.totalPlayers]);
            csvData.push(['Average Experience', teamStats.avgExperience]);
            csvData.push(['Experience Variance', teamStats.experienceVariance]);
            csvData.push(['Teams with Goalkeepers', teamStats.teamsWithGoalkeepers]);
            csvData.push(['Teams with Team Reps', teamStats.teamsWithTRs]);
            csvData.push(['Reciprocal Pairs Honored', teamStats.reciprocalPairs]);
            
            csvData.push(['', '']); // Empty row
            csvData.push(['Team', 'Players', 'Avg Experience', 'Goalkeepers', 'Team Reps']);
            
            generatedTeams.forEach(team => {
                const avgExp = team.players.length > 0 ? 
                    (team.totalExperience / team.players.length).toFixed(2) : '0.00';
                csvData.push([
                    team.name,
                    team.players.length,
                    avgExp,
                    team.goalkeepers,
                    team.teamReps
                ]);
            });

            downloadCSV(csvData, 'team_statistics.csv');
        }

        function downloadCSV(data, filename) {
            const csv = Papa.unparse(data);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
        }
    </script>
</body>
</html>
